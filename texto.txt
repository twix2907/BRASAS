Laravel Sanctum
Introduction
Laravel Sanctum provides a featherweight authentication system for SPAs (single page applications), mobile applications, and simple, token based APIs. Sanctum allows each user of your application to generate multiple API tokens for their account. These tokens may be granted abilities / scopes which specify which actions the tokens are allowed to perform.

How it Works
Laravel Sanctum exists to solve two separate problems. Let's discuss each before digging deeper into the library.

API Tokens
First, Sanctum is a simple package you may use to issue API tokens to your users without the complication of OAuth. This feature is inspired by GitHub and other applications which issue "personal access tokens". For example, imagine the "account settings" of your application has a screen where a user may generate an API token for their account. You may use Sanctum to generate and manage those tokens. These tokens typically have a very long expiration time (years), but may be manually revoked by the user anytime.

Laravel Sanctum offers this feature by storing user API tokens in a single database table and authenticating incoming HTTP requests via the Authorization header which should contain a valid API token.

SPA Authentication
Second, Sanctum exists to offer a simple way to authenticate single page applications (SPAs) that need to communicate with a Laravel powered API. These SPAs might exist in the same repository as your Laravel application or might be an entirely separate repository, such as an SPA created using Next.js or Nuxt.

For this feature, Sanctum does not use tokens of any kind. Instead, Sanctum uses Laravel's built-in cookie based session authentication services. Typically, Sanctum utilizes Laravel's web authentication guard to accomplish this. This provides the benefits of CSRF protection, session authentication, as well as protects against leakage of the authentication credentials via XSS.

Sanctum will only attempt to authenticate using cookies when the incoming request originates from your own SPA frontend. When Sanctum examines an incoming HTTP request, it will first check for an authentication cookie and, if none is present, Sanctum will then examine the Authorization header for a valid API token.

It is perfectly fine to use Sanctum only for API token authentication or only for SPA authentication. Just because you use Sanctum does not mean you are required to use both features it offers.

Installation
You may install Laravel Sanctum via the install:api Artisan command:

php artisan install:api

Next, if you plan to utilize Sanctum to authenticate an SPA, please refer to the SPA Authentication section of this documentation.

Configuration
Overriding Default Models
Although not typically required, you are free to extend the PersonalAccessToken model used internally by Sanctum:

use Laravel\Sanctum\PersonalAccessToken as SanctumPersonalAccessToken;
 
class PersonalAccessToken extends SanctumPersonalAccessToken
{
    // ...
}

Then, you may instruct Sanctum to use your custom model via the usePersonalAccessTokenModel method provided by Sanctum. Typically, you should call this method in the boot method of your application's AppServiceProvider file:

use App\Models\Sanctum\PersonalAccessToken;
use Laravel\Sanctum\Sanctum;
 
/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Sanctum::usePersonalAccessTokenModel(PersonalAccessToken::class);
}

API Token Authentication
You should not use API tokens to authenticate your own first-party SPA. Instead, use Sanctum's built-in SPA authentication features.

Issuing API Tokens
Sanctum allows you to issue API tokens / personal access tokens that may be used to authenticate API requests to your application. When making requests using API tokens, the token should be included in the Authorization header as a Bearer token.

To begin issuing tokens for users, your User model should use the Laravel\Sanctum\HasApiTokens trait:

use Laravel\Sanctum\HasApiTokens;
 
class User extends Authenticatable
{
    use HasApiTokens, HasFactory, Notifiable;
}

To issue a token, you may use the createToken method. The createToken method returns a Laravel\Sanctum\NewAccessToken instance. API tokens are hashed using SHA-256 hashing before being stored in your database, but you may access the plain-text value of the token using the plainTextToken property of the NewAccessToken instance. You should display this value to the user immediately after the token has been created:

use Illuminate\Http\Request;
 
Route::post('/tokens/create', function (Request $request) {
    $token = $request->user()->createToken($request->token_name);
 
    return ['token' => $token->plainTextToken];
});

You may access all of the user's tokens using the tokens Eloquent relationship provided by the HasApiTokens trait:

foreach ($user->tokens as $token) {
    // ...
}

Token Abilities
Sanctum allows you to assign "abilities" to tokens. Abilities serve a similar purpose as OAuth's "scopes". You may pass an array of string abilities as the second argument to the createToken method:

return $user->createToken('token-name', ['server:update'])->plainTextToken;

When handling an incoming request authenticated by Sanctum, you may determine if the token has a given ability using the tokenCan or tokenCant methods:

if ($user->tokenCan('server:update')) {
    // ...
}
 
if ($user->tokenCant('server:update')) {
    // ...
}

Token Ability Middleware
Sanctum also includes two middleware that may be used to verify that an incoming request is authenticated with a token that has been granted a given ability. To get started, define the following middleware aliases in your application's bootstrap/app.php file:

use Laravel\Sanctum\Http\Middleware\CheckAbilities;
use Laravel\Sanctum\Http\Middleware\CheckForAnyAbility;
 
->withMiddleware(function (Middleware $middleware) {
    $middleware->alias([
        'abilities' => CheckAbilities::class,
        'ability' => CheckForAnyAbility::class,
    ]);
})

The abilities middleware may be assigned to a route to verify that the incoming request's token has all of the listed abilities:

Route::get('/orders', function () {
    // Token has both "check-status" and "place-orders" abilities...
})->middleware(['auth:sanctum', 'abilities:check-status,place-orders']);

The ability middleware may be assigned to a route to verify that the incoming request's token has at least one of the listed abilities:

Route::get('/orders', function () {
    // Token has the "check-status" or "place-orders" ability...
})->middleware(['auth:sanctum', 'ability:check-status,place-orders']);

First-Party UI Initiated Requests
For convenience, the tokenCan method will always return true if the incoming authenticated request was from your first-party SPA and you are using Sanctum's built-in SPA authentication.

However, this does not necessarily mean that your application has to allow the user to perform the action. Typically, your application's authorization policies will determine if the token has been granted the permission to perform the abilities as well as check that the user instance itself should be allowed to perform the action.

Por ejemplo, si imaginamos una aplicación que administra servidores, esto podría significar verificar que el token esté autorizado para actualizar servidores y que el servidor pertenece al usuario:

return $request->user()->id === $server->user_id &&
       $request->user()->tokenCan('server:update')

Al principio, permitiendo que tokenCan método a llamar y siempre regresar true Para las solicitudes iniciadas por la interfaz de usuario de primera parte puede parecer extraño; sin embargo, es conveniente poder asumir siempre que hay un token de API disponible y que se puede inspeccionar a través de tokenCan método. Al adoptar este enfoque, siempre puedes llamar a la tokenCan método dentro de las políticas de autorización de su aplicación sin preocuparse de si la solicitud se activó desde la interfaz de usuario de su aplicación o fue iniciada por uno de los consumidores externos de su API.

Protegiendo rutas
Para proteger las rutas de modo que todas las solicitudes entrantes deban autenticarse, debe adjuntar el sanctum protección de autenticación para sus rutas protegidas dentro de su routes/web.php y routes/api.php archivos de ruta. Este protector garantizará que las solicitudes entrantes se autentiquen como solicitudes con estado y autenticadas por cookies o contengan un encabezado de token API válido si la solicitud proviene de un tercero.

Quizás te preguntes por qué te sugerimos que autentiques las rutas dentro de tu aplicación routes/web.php archivo que utiliza el sanctum guardia. Recuerde, Sanctum primero intentará autenticar las solicitudes entrantes utilizando la típica cookie de autenticación de sesión de Laravel. Si esa cookie no está presente, Sanctum intentará autenticar la solicitud utilizando un token en la solicitud Authorization cabecera. Además, autenticar todas las solicitudes mediante Sanctum garantiza que siempre podamos llamar al tokenCan método en la instancia de usuario actualmente autenticada:

use Illuminate\Http\Request;
 
Route::get('/user', function (Request $request) {
    return $request->user();
})->middleware('auth:sanctum');

Revocación de tokens
Puede "revocar" tokens eliminándolos de su base de datos utilizando el tokens relación que proporciona el Laravel\Sanctum\HasApiTokens rasgo:

// Revoke all tokens...
$user->tokens()->delete();
 
// Revoke the token that was used to authenticate the current request...
$request->user()->currentAccessToken()->delete();
 
// Revoke a specific token...
$user->tokens()->where('id', $tokenId)->delete();

Caducidad del token
De forma predeterminada, los tokens Sanctum nunca caducan y solo pueden ser invalidados por revocando el token. Sin embargo, si desea configurar un tiempo de vencimiento para los tokens API de su aplicación, puede hacerlo a través de expiration Opción de configuración definida en su aplicación sanctum archivo de configuración. Esta opción de configuración define la cantidad de minutos hasta que un token emitido se considerará vencido:

'expiration' => 525600,

Si desea especificar el tiempo de vencimiento de cada token de forma independiente, puede hacerlo proporcionando el tiempo de vencimiento como tercer argumento para el createToken método:

return $user->createToken(
    'token-name', ['*'], now()->addWeek()
)->plainTextToken;

Si ha configurado un tiempo de vencimiento de token para su aplicación, es posible que también desee hacerlo programar una tarea para podar los tokens vencidos de su aplicación. Afortunadamente, Sanctum incluye un sanctum:prune-expired Mandato artesanal que puedes utilizar para lograr esto. Por ejemplo, puede configurar una tarea programada para eliminar todos los registros de la base de datos de tokens vencidos que hayan estado vencidos durante al menos 24 horas:

use Illuminate\Support\Facades\Schedule;
 
Schedule::command('sanctum:prune-expired --hours=24')->daily();

Autenticación SPA
Sanctum también existe para proporcionar un método simple para autenticar aplicaciones de página única (SPA) que necesitan comunicarse con una API impulsada por Laravel. Estos SPA pueden existir en el mismo repositorio que su aplicación Laravel o pueden ser un repositorio completamente separado.

Para esta función, Sanctum no utiliza tokens de ningún tipo. En su lugar, Sanctum utiliza los servicios de autenticación de sesiones basados en cookies integrados de Laravel. Este enfoque de autenticación proporciona los beneficios de la protección CSRF, la autenticación de sesión y protege contra fugas de credenciales de autenticación a través de XSS.

Para autenticarse, su SPA y API deben compartir el mismo dominio de nivel superior. Sin embargo, pueden colocarse en diferentes subdominios. Además, debes asegurarte de enviar el Accept: application/json encabezado y ya sea el Referer o Origin encabezado con su solicitud.

Configuración
Configuración de sus dominios propios
Primero, debes configurar desde qué dominios realizará solicitudes tu SPA. Puede configurar estos dominios utilizando el stateful Opción de configuración en su sanctum archivo de configuración. Esta configuración determina qué dominios mantendrán una autenticación "con estado" utilizando cookies de sesión de Laravel al realizar solicitudes a su API.

Para ayudarlo a configurar sus dominios con estado propios, Sanctum proporciona dos funciones auxiliares que puede incluir en la configuración. În primul rând, Sanctum::currentApplicationUrlWithPort() devolverá la URL de la aplicación actual desde el APP_URL variable de entorno, y Sanctum::currentRequestHost() inyectará un marcador de posición en la lista de dominios con estado que, en tiempo de ejecución, será reemplazado por el host de la solicitud actual para que todas las solicitudes con el mismo dominio se consideren con estado.

Si accede a su aplicación a través de una URL que incluye un puerto (127.0.0.1:8000), debes asegurarte de incluir el número de puerto con el dominio.

Middleware Sanctum
A continuación, debe indicarle a Laravel que las solicitudes entrantes de su SPA pueden autenticarse utilizando las cookies de sesión de Laravel, al mismo tiempo que permite que las solicitudes de terceros o aplicaciones móviles se autentiquen utilizando tokens API. Esto se puede lograr fácilmente invocando el statefulApi método de middleware en su aplicación bootstrap/app.php fișier:

->withMiddleware(function (Middleware $middleware) {
    $middleware->statefulApi();
})

CORS y Cookies
Si tiene problemas para autenticarse con su aplicación desde un SPA que se ejecuta en un subdominio separado, es probable que haya configurado mal su CORS (intercambio de recursos entre orígenes) o la configuración de cookies de sesión.

El config/cors.php El archivo de configuración no se publica de forma predeterminada. Si necesitas personalizar las opciones CORS de Laravel, debes publicar el archivo completo cors archivo de configuración utilizando el config:publish Comando artesanal:

php artisan config:publish cors

A continuación, debe asegurarse de que la configuración CORS de su aplicación devuelva el Access-Control-Allow-Credentials encabezado con un valor de True. Esto se puede lograr estableciendo el supports_credentials Opción dentro de su aplicación config/cors.php archivo de configuración a true.

Además, debes habilitar el withCredentials y withXSRFToken Opciones en el global de su aplicación axios instancia. Normalmente, esto debe realizarse en su resources/js/bootstrap.js archivo. Si no está utilizando Axios para realizar solicitudes HTTP desde su interfaz, debe realizar la configuración equivalente en su propio cliente HTTP:

axios.defaults.withCredentials = true;
axios.defaults.withXSRFToken = true;

Por último, debe asegurarse de que la configuración del dominio de cookies de sesión de su aplicación admita cualquier subdominio de su dominio raíz. Puede lograr esto anteponiendo al dominio un encabezado . dentro de su aplicación config/session.php fișier de configurare:

'domain' => '.domain.com',

Autenticar
Protección CSRF
Para autenticar su SPA, la página de "inicio de sesión" de su SPA primero debe realizar una solicitud al /sanctum/csrf-cookie Punto final para inicializar la protección CSRF para la aplicación:

axios.get('/sanctum/csrf-cookie').then(response => {
    // Login...
});

Durante esta solicitud, Laravel establecerá un XSRF-TOKEN cookie que contiene el token CSRF actual. Luego, este token debe decodificarse en URL y pasarse en un X-XSRF-TOKEN encabezado en solicitudes posteriores, lo que algunas bibliotecas de clientes HTTP como Axios y Angular HttpClient harán automáticamente por usted. Si su biblioteca HTTP de JavaScript no establece el valor para usted, deberá configurarlo manualmente X-XSRF-TOKEN encabezado para que coincida con el valor decodificado de URL del XSRF-TOKEN cookie que se establece mediante esta ruta.

Iniciar sesión
Una vez que se haya inicializado la protección CSRF, debe crear una POST solicitud a su aplicación Laravel /login ruta. Esto /login La ruta puede ser implementado manualmente o usar un paquete de autenticación sin cabeza como Fortificar Laravel.

Si la solicitud de inicio de sesión es exitosa, se autenticará y las solicitudes posteriores a las rutas de su aplicación se autenticarán automáticamente a través de la cookie de sesión que la aplicación Laravel emitió a su cliente. Además, dado que su solicitud ya realizó una solicitud a la /sanctum/csrf-cookie ruta, las solicitudes posteriores deberían recibir automáticamente protección CSRF siempre que su cliente HTTP JavaScript envíe el valor del XSRF-TOKEN galleta en el X-XSRF-TOKEN cabecera.

Por supuesto, si la sesión de su usuario expira debido a la falta de actividad, las solicitudes posteriores a la aplicación Laravel pueden recibir una respuesta de error HTTP 401 o 419. En este caso, deberás redirigir al usuario a la página de inicio de sesión de tu SPA.

Eres libre de escribir el tuyo propio /login punto final; sin embargo, debe asegurarse de que autentique al usuario utilizando el estándar Servicios de autenticación basados en sesiones que proporciona Laravel. Normalmente, esto significa utilizar el web guardia de autenticación.

Protegiendo rutas
Para proteger las rutas de modo que todas las solicitudes entrantes deban autenticarse, debe adjuntar el sanctum protección de autenticación de sus rutas API dentro de su routes/api.php archivo. Este protector garantizará que las solicitudes entrantes se autentiquen como solicitudes autenticadas con estado de su SPA o contengan un encabezado de token API válido si la solicitud es de un tercero:

use Illuminate\Http\Request;
 
Route::get('/user', function (Request $request) {
    return $request->user();
})->middleware('auth:sanctum');

Autorización de canales de transmisión privados
Si su SPA necesita autenticarse con canales de transmisión privados / de presencia, deberías eliminar el channels entrada desde el withRouting método contenido en su aplicación bootstrap/app.php archivo. En lugar de ello, deberías invocar el withBroadcasting método para que pueda especificar el middleware correcto para las rutas de transmisión de su aplicación:

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        web: __DIR__.'/../routes/web.php',
        // ...
    )
    ->withBroadcasting(
        __DIR__.'/../routes/channels.php',
        ['prefix' => 'api', 'middleware' => ['api', 'auth:sanctum']],
    )

A continuación, para que las solicitudes de autorización de Pusher tengan éxito, deberá proporcionar un Pusher personalizado authorizer al inicializar Eco de Laravel. Esto permite que su aplicación configure Pusher para usar el axios instancia que es configurado correctamente para solicitudes entre dominios:

window.Echo = new Echo({
    broadcaster: "pusher",
    cluster: import.meta.env.VITE_PUSHER_APP_CLUSTER,
    encrypted: true,
    key: import.meta.env.VITE_PUSHER_APP_KEY,
    authorizer: (channel, options) => {
        return {
            authorize: (socketId, callback) => {
                axios.post('/api/broadcasting/auth', {
                    socket_id: socketId,
                    channel_name: channel.name
                })
                .then(response => {
                    callback(false, response.data);
                })
                .catch(error => {
                    callback(true, error);
                });
            }
        };
    },
})

Autenticación de aplicaciones móviles
También puede utilizar tokens Sanctum para autenticar las solicitudes de su aplicación móvil a su API. El proceso para autenticar solicitudes de aplicaciones móviles es similar a autenticar solicitudes de API de terceros; sin embargo, existen pequeñas diferencias en cómo emitirá los tokens API.

Emisión de tokens API
Para comenzar, cree una ruta que acepte el correo electrónico / nombre de usuario, la contraseña y el nombre del dispositivo del usuario, luego intercambie esas credenciales por un nuevo token Sanctum. El "nombre del dispositivo" proporcionado a este punto final tiene fines informativos y puede ser cualquier valor que desee. En general, el valor del nombre del dispositivo debe ser un nombre que el usuario reconozca, como "iPhone 12 de Nuno".

Normalmente, realizará una solicitud al punto final del token desde la pantalla de "inicio de sesión" de su aplicación móvil. El punto final devolverá el token API de texto sin formato que luego podrá almacenarse en el dispositivo móvil y usarse para realizar solicitudes API adicionales:

use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\ValidationException;
 
Route::post('/sanctum/token', function (Request $request) {
    $request->validate([
        'email' => 'required|email',
        'password' => 'required',
        'device_name' => 'required',
    ]);
 
    $user = User::where('email', $request->email)->first();
 
    if (! $user || ! Hash::check($request->password, $user->password)) {
        throw ValidationException::withMessages([
            'email' => ['The provided credentials are incorrect.'],
        ]);
    }
 
    return $user->createToken($request->device_name)->plainTextToken;
});

Cuando la aplicación móvil usa el token para realizar una solicitud de API a su aplicación, debe pasar el token en el Authorization encabezado como Bearer token.

Al emitir tokens para una aplicación móvil, también eres libre de especificar habilidades simbólicas.

Protegiendo rutas
Como se documentó anteriormente, puede proteger las rutas para que todas las solicitudes entrantes se autentiquen adjuntando el sanctum protección de autenticación de las rutas:

Route::get('/user', function (Request $request) {
    return $request->user();
})->middleware('auth:sanctum');

Revocación de tokens
Para permitir a los usuarios revocar tokens API emitidos a dispositivos móviles, puede enumerarlos por nombre, junto con un botón "Revocar", dentro de una parte de "configuración de cuenta" de la interfaz de usuario de su aplicación web. Cuando el usuario hace clic en el botón "Revocar", puede eliminar el token de la base de datos. Recuerde, puede acceder a los tokens API de un usuario a través de tokens relación proporcionada por la Laravel\Sanctum\HasApiTokens rasgo:

// Revoke all tokens...
$user->tokens()->delete();
 
// Revoke a specific token...
$user->tokens()->where('id', $tokenId)->delete();

Testing
Durante las pruebas, el Sanctum::actingAs El método se puede utilizar para autenticar a un usuario y especificar qué habilidades se deben otorgar a su token:

Plaga
Unidad PHP

use App\Models\User;
use Laravel\Sanctum\Sanctum;
 
test('task list can be retrieved', function () {
    Sanctum::actingAs(
        User::factory()->create(),
        ['view-tasks']
    );
 
    $response = $this->get('/api/task');
 
    $response->assertOk();
});
Si desea otorgar todas las habilidades al token, debe incluir * en la lista de habilidades proporcionada al actingAs método:

Sanctum::actingAs(
    User::factory()->create(),
    ['*']
);